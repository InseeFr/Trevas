(self.webpackChunktrevas_documentation=self.webpackChunktrevas_documentation||[]).push([[6466],{50748:(e,n,t)=>{"use strict";t.d(n,{A:()=>i});var a=t(96540),r=t(7351),o=t(74848);const i=(0,a.memo)((e=>{const{script:n}=e;return(0,o.jsx)(r.A,{children:()=>{const e=t(2317).AntlrEditor,a=t(56468),{monarchDefinition:r,getSuggestionsFromRange:i}=t(83858),s={...a,getSuggestionsFromRange:i,monarchDefinition:r};return(0,o.jsx)(e,{script:n,tools:s,height:"10vh",options:{minimap:{enabled:!1},lineNumbers:!1}})}})}))},83858:(e,n,t)=>{"use strict";t.r(n),t.d(n,{getSuggestionsFromRange:()=>d,monarchDefinition:()=>a});const a=JSON.parse('{"defaultToken":"invalid","tokenPostfix":".vtl","keywords":[],"typeKeywords":[],"operators":[],"specials":[],"variables":[],"symbols":"_RGX_/[=><!~?:&|+\\\\-*\\\\/\\\\^%]+/","escapes":"_RGX_/\\\\\\\\(?:[abfnrtv\\\\\\\\\\"\']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/","digits":"_RGX_/\\\\d+(_+\\\\d+)*/","octaldigits":"_RGX_/[0-7]+(_+[0-7]+)*/","binarydigits":"_RGX_/[0-1]+(_+[0-1]+)*/","hexdigits":"_RGX_/[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/","regexpctl":"_RGX_/[(){}\\\\[\\\\]\\\\$\\\\^|\\\\-*+?\\\\.]/","regexpesc":"_RGX_/\\\\\\\\(?:[bBdDfnrstvwWn0\\\\\\\\\\\\/]|@regexpctl|c[A-Z]|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4})/","tokenizer":{"root":[["_RGX_/[{}]/","delimiter.bracket"],{"include":"common"}],"common":[["_RGX_/[a-z_$][\\\\w$]*/",{"cases":{"@typeKeywords":"keyword","@keywords":"keyword","@variables":"variable","@default":"identifier"}}],["_RGX_/[A-Z][\\\\w\\\\$]*/",{"cases":{"@typeKeywords":"keyword","@keywords":"keyword","@variables":"variable","@default":"identifier"}}],{"include":"@whitespace"},["_RGX_/\\\\/(?=([^\\\\\\\\\\\\/]|\\\\\\\\.)+\\\\/([gimsuy]*)(\\\\s*)(\\\\.|;|\\\\/|,|\\\\)|\\\\]|\\\\}|$))/",{"token":"regexp","bracket":"@open","next":"@regexp"}],["_RGX_/[()\\\\[\\\\]]/","delimiter.bracket"],["_RGX_/[<>](?!@symbols)/","delimiter.bracket"],["_RGX_/@symbols/",{"cases":{"@operators":"operator","@specials":"operator.special","@default":""}}],["_RGX_/(@digits)[eE]([\\\\-+]?(@digits))?/","number.float"],["_RGX_/(@digits)\\\\.(@digits)([eE][\\\\-+]?(@digits))?/","number.float"],["_RGX_/0[xX](@hexdigits)/","number.hex"],["_RGX_/0[oO]?(@octaldigits)/","number.octal"],["_RGX_/0[bB](@binarydigits)/","number.binary"],["_RGX_/(@digits)/","number"],["_RGX_/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*$/","string.invalid"],["_RGX_/\'([^\'\\\\\\\\]|\\\\\\\\.)*$/","string.invalid"],["_RGX_/\\"/","string","@string_double"],["_RGX_/\'/","string","@string_single"],["_RGX_/`/","string","@string_backtick"]],"whitespace":[["_RGX_/[ \\\\t\\\\r\\\\n]+/",""],["_RGX_/\\\\/\\\\*\\\\*(?!\\\\/)/","comment.doc","@jsdoc"],["_RGX_/\\\\/\\\\*/","comment","@comment"],["_RGX_/\\\\/\\\\/.*$/","comment"]],"comment":[["_RGX_/[^\\\\/*]+/","comment"],["_RGX_/\\\\*\\\\//","comment","@pop"],["_RGX_/[\\\\/*]/","comment"]],"jsdoc":[["_RGX_/[^\\\\/*]+/","comment.doc"],["_RGX_/\\\\*\\\\//","comment.doc","@pop"],["_RGX_/[\\\\/*]/","comment.doc"]],"regexp":[["_RGX_/(\\\\{)(\\\\d+(?:,\\\\d*)?)(\\\\})/",["regexp.escape.control","regexp.escape.control","regexp.escape.control"]],["_RGX_/(\\\\[)(\\\\^?)(?=(?:[^\\\\]\\\\\\\\\\\\/]|\\\\\\\\.)+)/",["regexp.escape.control",{"token":"regexp.escape.control","next":"@regexrange"}]],["_RGX_/(\\\\()(\\\\?:|\\\\?=|\\\\?!)/",["regexp.escape.control","regexp.escape.control"]],["_RGX_/[()]/","regexp.escape.control"],["_RGX_/@regexpctl/","regexp.escape.control"],["_RGX_/[^\\\\\\\\\\\\/]/","regexp"],["_RGX_/@regexpesc/","regexp.escape"],["_RGX_/\\\\\\\\\\\\./","regexp.invalid"],["_RGX_/(\\\\/)([gimsuy]*)/",[{"token":"regexp","bracket":"@close","next":"@pop"},"keyword.other"]]],"regexrange":[["_RGX_/-/","regexp.escape.control"],["_RGX_/\\\\^/","regexp.invalid"],["_RGX_/@regexpesc/","regexp.escape"],["_RGX_/[^\\\\]]/","regexp"],["_RGX_/\\\\]/",{"token":"regexp.escape.control","next":"@pop","bracket":"@close"}]],"string_double":[["_RGX_/[^\\\\\\\\\\"]+/","string"],["_RGX_/@escapes/","string.escape"],["_RGX_/\\\\\\\\./","string.escape.invalid"],["_RGX_/\\"/","string","@pop"]],"string_single":[["_RGX_/[^\\\\\\\\\']+/","string"],["_RGX_/@escapes/","string.escape"],["_RGX_/\\\\\\\\./","string.escape.invalid"],["_RGX_/\'/","string","@pop"]],"string_backtick":[["_RGX_/\\\\$\\\\{/",{"token":"delimiter.bracket","next":"@bracketCounting"}],["_RGX_/[^\\\\\\\\`$]+/","string"],["_RGX_/@escapes/","string.escape"],["_RGX_/\\\\\\\\./","string.escape.invalid"],["_RGX_/`/","string","@pop"]],"bracketCounting":[["_RGX_/\\\\{/","delimiter.bracket","@bracketCounting"],["_RGX_/\\\\}/","delimiter.bracket","@pop"],{"include":"common"}]}}');var r=t(69912);const o=r.languages.CompletionItemKind.Function,i=(r.languages.CompletionItemKind.Variable,r.languages.CompletionItemKind.Keyword),s=r.languages.CompletionItemKind.Snippet,l=r.languages.CompletionItemInsertTextRule.InsertAsSnippet,d=e=>[{label:"eval",kind:o,insertText:"eval",range:e,documentation:{value:"The eval operator invokes an external, non-VTL routine, and returns its result as a Data Set or a scalar. \n\n **Syntax** \n\n    eval(externalRoutineName({argument}{,argument}*) language languageName returns outputType)"}},{label:"if",kind:i,insertText:"if",range:e,documentation:{value:"Conditional operator  \n\n **Syntax** \n\n    if condition then thenOperand else elseOperand "}},{label:"then",kind:i,insertText:"then",range:e,documentation:{value:"Conditional operator  \n\n **Syntax** \n\n    if condition then thenOperand else elseOperand "}},{label:"else",kind:i,insertText:"else",range:e,documentation:{value:"Conditional operator  \n\n **Syntax** \n\n    if condition then thenOperand else elseOperand "}},{label:"using",kind:i,insertText:"using",range:e},{label:"with",kind:i,insertText:"with",range:e},{label:"current_date",kind:o,insertText:"current_date()",range:e,documentation:{value:"The operator current_date returns the current time as a date type.   \n\n **Syntax** \n\n    current_date() "}},{label:"on",kind:i,insertText:"on",range:e},{label:"drop",kind:i,insertText:"drop",range:e,documentation:{value:"The operator takes as input a Data Set (op) and  some Component names of such a Data Set (comp).   \n\n **Syntax** \n\n    op [drop  comp { , comp }* ]  "}},{label:"keep",kind:i,insertText:"keep",range:e,documentation:{value:"The operator takes as input a Data Set (op) and some Component names of such a Data Set (comp).  \n\n **Syntax** \n\n    op [ keep comp {, comp }* ] "}},{label:"calc",kind:i,insertText:"calc",range:e,documentation:{value:"The operator calculates new Identifier, Measure or Attribute Components on the basis of sub-expressions at Component level.   ***\n\n*Example*\n\n    DS_1 [ calc Me_3 := Me_1 + Me_2] "}},{label:"attrcalc",kind:i,insertText:"attrcalc",range:e},{label:"rename",kind:i,insertText:"rename",range:e,documentation:{value:"The operator assigns new names to one or more Components (Identifier, Measure or Attribute Components).    \n\n **Syntax** \n\n    op [ rename  comp_from  to  comp_to  { , comp_from  to  comp_to}*  ]   "}},{label:"as",kind:i,insertText:"as",range:e},{label:"and",kind:i,insertText:"and",range:e,documentation:{value:"The and operator returns TRUE if both operands are TRUE, otherwise FALSE. The two operands must be of boolean type.  \n\n **Syntax** \n\n    op1 and op2  "}},{label:"or",kind:i,insertText:"or",range:e,documentation:{value:"The or operator returns TRUE if at least one of the operands is TRUE, otherwise FALSE. The two operands must be of boolean type.  \n\n **Syntax** \n\n    op1 or op2  "}},{label:"xor",kind:i,insertText:"xor",range:e,documentation:{value:"The xor operator returns TRUE if only one of the operand is TRUE (but not both), FALSE otherwise. The two operands must be of boolean type.   \n\n **Syntax** \n\n    op1 xor op2  "}},{label:"not",kind:i,insertText:"not",range:e,documentation:{value:"The not operator returns TRUE if op is FALSE, otherwise TRUE. The input operand must be of boolean type.  \n\n **Syntax** \n\n    not op2  "}},{label:"between",kind:o,insertText:"between",range:e,documentation:{value:"The operator returns TRUE if op is greater than or equal to from and lower than or equal to to.   \n\n **Syntax** \n\n    between (op, from, to)  "}},{label:"levenshtein",kind:o,insertText:"levenshtein",range:e,documentation:{value:"The operator returns the levenshtein distance between the two inputed strings.   \n\n **Syntax** \n\n    levenshtein (left, right)  "}},{label:"random",kind:o,insertText:"random",range:e,documentation:{value:"The operator returns a random decimal number >= 0 and <1.  \n\n **Syntax** \n\n    random()"}},{label:"in",kind:i,insertText:"in",range:e,documentation:{value:"The in operator returns TRUE if op belongs to the collection, FALSE otherwise.    \n\n **Syntax** \n\n    op in collection  "}},{label:"not_in",kind:i,insertText:"not_in",range:e,documentation:{value:"The not_in operator returns FALSE if op belongs to the collection, TRUE otherwise.     \n\n **Syntax** \n\n    op not_in collection  "}},{label:"isnull",kind:o,insertText:"isnull",range:e,documentation:{value:"The operator returns TRUE if the value of the operand is NULL, FALSE otherwise.     \n\n **Syntax** \n\n    isnull(op)  "}},{label:"ex",kind:i,insertText:"ex",range:e},{label:"union",kind:o,insertText:"union",range:e,documentation:{value:"The union operator implements the union of functions (i.e., Data Sets).   \n\n **Syntax** \n\n    union ( ds { , ds }*) "}},{label:"diff",kind:i,insertText:"diff",range:e},{label:"symdiff",kind:o,insertText:"symdiff",range:e,documentation:{value:"The operator implements the symmetric set difference between functions (i.e. Data Sets), interpreting the Data Points of the input Data Sets as the elements in the operand Sets.   \n\n **Syntax** \n\n    symdiff(ds1, ds) "}},{label:"intersect",kind:o,insertText:"intersect",range:e,documentation:{value:"The intersect operator implements the intersection of functions (i.e., Data Sets).   \n\n **Syntax** \n\n    intersect ( ds { , ds }*) "}},{label:"keys",kind:i,insertText:"KEYS",range:e},{label:"check",kind:o,insertText:"check",range:e,documentation:{value:"*Syntax*\n\n    check ( op { errorcode errorcode } { errorlevel errorlevel } { imbalance imbalance } { output } )   \n\noutput ::=  invalid | all "}},{label:"exists_in",kind:o,insertText:"exists_in",range:e,documentation:{value:"The operator returns TRUE if the value of the operand is NULL, FALSE otherwise.     \n\n **Syntax** \n\n    exists_in ( op1, op2 { , retain } )   \n\n *retain* ::= true | false | all"}},{label:"to",kind:i,insertText:"to",range:e},{label:"return",kind:i,insertText:"return",range:e},{label:"imbalance",kind:i,insertText:"imbalance",range:e,documentation:{value:"Imbalance is a numeric mono-measure Data Set with the same Identifiers of op. If not specified then imbalance is NULL"}},{label:"errorcode",kind:i,insertText:"errorcode",range:e},{label:"all",kind:i,insertText:"all",range:e},{label:"aggr",kind:i,insertText:"aggr",range:e,documentation:{value:"The operator aggr calculates aggregations of dependent Components (Measures or Attributes) on the basis of sub-expressions at Component level.     \n\n **Syntax** \n\n    op [ aggr aggrClause { groupingClause } ]  "}},{label:"errorlevel",kind:i,insertText:"errorlevel",range:e},{label:"order",kind:i,insertText:"order",range:e},{label:"by",kind:i,insertText:"by",range:e},{label:"rank",kind:o,insertText:"rank",range:e,documentation:{value:"Rank (order number) of a Data Point in an ordered set of Data Points.   \n\n **Syntax** \n\n    rank( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    rank( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"asc",kind:i,insertText:"asc",range:e},{label:"desc",kind:i,insertText:"desc",range:e},{label:"min",kind:o,insertText:"min",range:e,documentation:{value:"Minimum value of a set of values .   \n\n **Syntax** \n\n    min( firstOperand  { , additionalOperand }* { groupingClause } \n\n     min( firstOperand { , additionalOperand }*  over ( analyticClause ) "}},{label:"max",kind:o,insertText:"max",range:e,documentation:{value:"Maximum value of a set of values .   \n\n **Syntax** \n\n    max( firstOperand  { , additionalOperand }* { groupingClause } \n\n     max( firstOperand { , additionalOperand }*  over ( analyticClause ) "}},{label:"first",kind:i,insertText:"first",range:e},{label:"last",kind:i,insertText:"last",range:e},{label:"indexof",kind:i,insertText:"indexof",range:e},{label:"abs",kind:o,insertText:"abs",range:e,documentation:{value:"The operator abs calculates the absolute value of a number.  \n\n For example:\n\n abs(-3.141) gives 3.141   \n\n **Syntax** \n\n    abs(op) "}},{label:"key",kind:i,insertText:"key",range:e},{label:"ln",kind:o,insertText:"ln",range:e,documentation:{value:"The operator ln calculates the natural logarithm of a number.   \n\n **Syntax** \n\n    ln(op) "}},{label:"log",kind:o,insertText:"log",range:e,documentation:{value:"The operator log calculates the logarithm of num base op.  \n\n **Syntax** \n\n    log(op , num) "}},{label:"trunc",kind:o,insertText:"trunc",range:e,documentation:{value:"The operator trunc truncates the operand to a number of positions at the right of the decimal point equal to the numDigit parameter.   \n\n **Syntax** \n\n    trunc ( op , numDigit ) "}},{label:"round",kind:o,insertText:"round",range:e,documentation:{value:"The operator round rounds the operand to a number of positions at the right of the decimal point equal to the numDigit parameter.    \n\n **Syntax** \n\n    round( op , numDigit  )  "}},{label:"power",kind:o,insertText:"power",range:e,documentation:{value:"The operator power raises a number (the base) to another one (the exponent).    \n\n **Syntax** \n\n    power(base , exponent) "}},{label:"mod",kind:o,insertText:"mod",range:e,documentation:{value:"The operator mod returns the remainder of op1 divided by op2. It returns op1 if divisor op2 is 0.   \n\n **Syntax** \n\n    mod(op1, op2 ) "}},{label:"length",kind:o,insertText:"length",range:e,documentation:{value:"Returns the length of a string.   \n\n **Syntax** \n\n    len( op ) "}},{label:"trim",kind:o,insertText:"trim",range:e,documentation:{value:'Removes trailing and leading whitespace from a string.  For example,    trim("Hello ") gives  "Hello".   \n\n **Syntax** \n\n    trim(operand) '}},{label:"upper",kind:o,insertText:"upper",range:e,documentation:{value:'Converts the character case of a string in upper case. For example,  upper("Hello") gives  "HELLO".   \n\n **Syntax** \n\n    upper(operand) '}},{label:"lower",kind:o,insertText:"lower",range:e,documentation:{value:'Converts the character case of a string in  lower case. For example,  lower("Hello") gives  "hello".   \n\n **Syntax** \n\n    lower(operand) '}},{label:"substr",kind:o,insertText:"substr",range:e,documentation:{value:"The operator extracts a substring from op, which must be string type. The substring starts from the start character of the input string and has a number of characters equal to the length parameter.    \n\n **Syntax** \n\n    substr ( op, start, length ) "}},{label:"sum",kind:o,insertText:"sum",range:e,documentation:{value:"Sum of a set of numbers.   \n\n **Syntax** \n\n    sun( firstOperand  { , additionalOperand }* { groupingClause }  "}},{label:"avg",kind:o,insertText:"avg",range:e,documentation:{value:"Average value of a set of numbers.   \n\n **Syntax** \n\n    avg( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    avg( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"median",kind:o,insertText:"median",range:e,documentation:{value:"Median value of a set of values .   \n\n **Syntax** \n\n    median( firstOperand  { , additionalOperand }* { groupingClause } \n\n    median( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"count",kind:o,insertText:"count",range:e,documentation:{value:"Number of Data Points.   \n\n **Syntax** \n\n    count( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    count( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"identifier",kind:i,insertText:"identifier",range:e},{label:"measure",kind:i,insertText:"measure",range:e},{label:"attribute",kind:i,insertText:"attribute",range:e},{label:"filter",kind:i,insertText:"filter",range:e,documentation:{value:"The operator takes as input a Data Set (op) and a boolean Component expression (filterCondition) and filters the input Data Points according to the evaluation of the condition.   \n\n **Syntax** \n\n    op[ filter  filterCondition ] "}},{label:"merge",kind:i,insertText:"merge",range:e},{label:"exp",kind:o,insertText:"exp",range:e,documentation:{value:"The operator exp returns e (base of the natural logarithm) raised to the op-th power.  \n\n **Syntax** \n\n    exp(op) "}},{label:"componentRole",kind:i,insertText:"componentRole",range:e},{label:"viral",kind:i,insertText:"viral",range:e},{label:"match_characters",kind:o,insertText:"match_characters",range:e,documentation:{value:"match_characters returns TRUE if op matches the regular expression regexp, FALSE otherwise.   \n\n **Syntax** \n\n    match_characters ( op , pattern ) "}},{label:"type",kind:i,insertText:"type",range:e},{label:"nvl",kind:o,insertText:"nvl",range:e,documentation:{value:"The operator nvl returns op2 when op1 is null, otherwise op1.    \n\n **Syntax** \n\n    nvl ( op1 , op2 )  "}},{label:"hierarchy",kind:o,insertText:"hierarchy",range:e,documentation:{value:"The hierarchy operator applies the rules of hr to op as specified in the parameters.   \n\n **Syntax** \n\n    hierarchy( op , hr { condition condComp { , condComp }* } { rule ruleComp } { mode } { input } { output } ) "}},{label:"invalid",kind:i,insertText:"invalid",range:e},{label:"valuedomain",kind:i,insertText:"valuedomain",range:e},{label:"variable",kind:i,insertText:"variable",range:e},{label:"data",kind:i,insertText:"data",range:e},{label:"structure",kind:i,insertText:"structure",range:e},{label:"dataset",kind:i,insertText:"dataset",range:e},{label:"operator",kind:i,insertText:"operator",range:e},{label:"define",kind:i,insertText:"define",range:e},{label:"datapoint",kind:i,insertText:"datapoint",range:e},{label:"hierarchical",kind:i,insertText:"hierarchical",range:e},{label:"ruleset",kind:i,insertText:"ruleset",range:e},{label:"rule",kind:i,insertText:"rule",range:e},{label:"end",kind:i,insertText:"end",range:e},{label:"alterDataset",kind:i,insertText:"alterDataset",range:e},{label:"ltrim",kind:o,insertText:"ltrim",range:e,documentation:{value:'Removes leading whitespace from a string.  For example,    trim(" Hello ") gives "Hello ".   \n\n **Syntax** \n\n    ltrim(operand) '}},{label:"rtrim",kind:o,insertText:"rtrim",range:e,documentation:{value:'Removes trailing whitespace from a string.  For example,    trim("Hello ") gives  "Hello".   \n\n **Syntax** \n\n    rtrim(operand) '}},{label:"instr",kind:o,insertText:"instr",range:e,documentation:{value:"The operator returns the position in the input string of a specified string (pattern).   \n\n **Syntax** \n\n    instr ( op, pattern, start, occurrence ) "}},{label:"replace",kind:o,insertText:"replace",range:e,documentation:{value:"Replaces all the occurrences of a specified string-pattern (pattern1) with another one (pattern2). If pattern2 is  omitted then all occurrences of pattern1 are removed   \n\n **Syntax** \n\n    replace (op , pattern1,  pattern2 ) "}},{label:"ceil",kind:o,insertText:"ceil",range:e,documentation:{value:"The operator ceil returns the smallest integer greater than or equal to op. \n\n For example:\n\n ceil(3.14159) gives 4   \n\n **Syntax** \n\n    ceil(op) "}},{label:"floor",kind:o,insertText:"floor",range:e,documentation:{value:"The operator floor returns the greatest integer which is smaller than or equal to op.  \n\n For example:\n\n floor(3.14159) gives 3   \n\n **Syntax** \n\n    floor(op) "}},{label:"sqrt",kind:o,insertText:"sqrt",range:e,documentation:{value:"The operator sqrt calculates the square root of a number.  \n\n **Syntax** \n\n    sqrt(op) "}},{label:"any",kind:i,insertText:"any",range:e},{label:"setdiff",kind:o,insertText:"setdiff",range:e,documentation:{value:"The operator implements the set difference of functions (i.e. Data Sets), interpreting the Data Points of the input Data Sets as the elements belonging to the operand sets, the minuend and the subtrahend, respectively.   \n\n **Syntax** \n\n    setdiff(ds1, ds2)  "}},{label:"stddev_pop",kind:o,insertText:"stddev_pop",range:e,documentation:{value:"Population standard deviation of a set of numbers.   \n\n **Syntax** \n\n    stddev_pop( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    stddev_pop( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"stddev_samp",kind:o,insertText:"stddev_samp",range:e,documentation:{value:"Sample standard deviation of a set of numbers.   \n\n **Syntax** \n\n    stddev_samp( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    stddev_samp( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"var_pop",kind:o,insertText:"var_pop",range:e,documentation:{value:"Population variance of a set of numbers.   \n\n **Syntax** \n\n    var_pop( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    var_pop( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"var_samp",kind:o,insertText:"var_samp",range:e,documentation:{value:"Sample variance of a set of numbers.   \n\n **Syntax** \n\n    var_samp( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    var_samp( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"group",kind:i,insertText:"group",range:e},{label:"except",kind:i,insertText:"except",range:e},{label:"having",kind:i,insertText:"having",range:e},{label:"first_value",kind:o,insertText:"first_value",range:e,documentation:{value:"First value in an ordered set of values .   \n\n **Syntax** \n\n    first_value( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    first_value( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"last_value",kind:o,insertText:"last_value",range:e,documentation:{value:"Last value in an ordered set of values.   \n\n **Syntax** \n\n    last_value( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    last_value( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"lag",kind:o,insertText:"lag",range:e,documentation:{value:"In an ordered set of Data Points, it returns the value(s) taken from a Data Point at a given physical offset prior to the current Data Point.   \n\n **Syntax** \n\n    lag( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    lag( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"lead",kind:o,insertText:"lead",range:e,documentation:{value:"In an ordered set of Data Points, it returns the value(s) taken from a Data Point at a given physical offset beyond the current Data Point .   \n\n **Syntax** \n\n    lead( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    lead( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"ratio_to_report",kind:o,insertText:"ratio_to_report",range:e,documentation:{value:"In an ordered set of Data Points, it returns the value(s) taken from a Data Point at a given physical offset beyond the current Data Point .   \n\n **Syntax** \n\n    ratio_to_report( firstOperand  { , additionalOperand }* { groupingClause }  \n\n    ratio_to_report( firstOperand { , additionalOperand }*  over ( analyticClause )) "}},{label:"over",kind:i,insertText:"over",range:e},{label:"preceding",kind:i,insertText:"preceding",range:e},{label:"following",kind:i,insertText:"following",range:e},{label:"unbounded",kind:i,insertText:"unbounded",range:e},{label:"partition",kind:i,insertText:"partition",range:e},{label:"rows",kind:i,insertText:"rows",range:e},{label:"range",kind:i,insertText:"range",range:e},{label:"current",kind:i,insertText:"current",range:e},{label:"valid",kind:i,insertText:"valid",range:e},{label:"fill_time_series",kind:o,insertText:"fill_time_series",range:e,documentation:{value:"The operator fills the possibly missing Data Points of all the time series belonging to the operand op within the time limits automatically determined by applying the limit_method.       \n\n **Syntax** \n\n    fill_time_series( op { , limitsMethod})  \n\n *limitsMethod* ::= single | all"}},{label:"flow_to_stock",kind:o,insertText:"flow_to_stock",range:e,documentation:{value:"This operator takes in input a Data Set which are interpreted as flows and calculates the change of the  corresponding stock since the beginning of each time series by summing the relevant flows. In other words, the  operator perform the cumulative sum from the first Data Point of each time series to each other following Data  Point of the same time series.  \n\n **Syntax** \n\n    flow_to_stock( op )  "}},{label:"stock_to_flow",kind:o,insertText:"stock_to_flow",range:e,documentation:{value:"This operator takes in input a Data Set of time series which is interpreted as stock data and, for each time series,  calculates the corresponding flow data by subtracting from the measure values of each regular period the  corresponding measure values of the previous one.   \n\n **Syntax** \n\n    stock_to_flow( op )  "}},{label:"timeshift",kind:o,insertText:"timeshift",range:e,documentation:{value:"This operator takes in input a Data Set of time series and, for each time series of the Data Set, shifts the reference time Identifier of a number of periods (of the time series) equal to the shift_number parameter.  If shift_number is negative, the shift is in the past, otherwise in the future  \n\n **Syntax** \n\n    timeshift( op ,  shiftNumber) "}},{label:"measures",kind:i,insertText:"measures",range:e},{label:"no_measures",kind:i,insertText:"no_measures",range:e},{label:"condition",kind:i,insertText:"condition",range:e},{label:"boolean",kind:i,insertText:"boolean",range:e},{label:"date",kind:i,insertText:"date",range:e},{label:"time_period",kind:i,insertText:"time_period",range:e},{label:"number",kind:i,insertText:"number",range:e},{label:"string",kind:i,insertText:"string",range:e},{label:"integer",kind:i,insertText:"integer",range:e},{label:"float",kind:i,insertText:"float",range:e},{label:"list",kind:i,insertText:"list",range:e},{label:"record",kind:i,insertText:"record",range:e},{label:"restrict",kind:i,insertText:"restrict",range:e},{label:"maxLength",kind:i,insertText:"maxLength",range:e},{label:"regexp",kind:i,insertText:"regexp",range:e},{label:"is",kind:i,insertText:"is",range:e},{label:"when",kind:i,insertText:"when",range:e},{label:"from",kind:i,insertText:"from",range:e},{label:"aggregates",kind:i,insertText:"aggregates",range:e},{label:"points",kind:i,insertText:"points",range:e},{label:"point",kind:i,insertText:"point",range:e},{label:"total",kind:i,insertText:"total",range:e},{label:"partial",kind:i,insertText:"partial",range:e},{label:"always",kind:i,insertText:"always",range:e},{label:"inner_join",kind:o,insertText:"inner_join",range:e,documentation:{value:"Join operator, a relational join of the input operands is performed, according to SQL inner"}},{label:"left_join",kind:o,insertText:"left_join",range:e,documentation:{value:"Join operator,  this is the left-most Data Set (left-outer sql)"}},{label:"cross_join",kind:o,insertText:"cross_join",range:e,documentation:{value:"Join operator,  Cartesian product"}},{label:"full_join",kind:o,insertText:"full_join",range:e,documentation:{value:"Join operator,  full outer (sql)"}},{label:"maps_from",kind:i,insertText:"maps_from",range:e},{label:"maps_to",kind:i,insertText:"maps_to",range:e},{label:"map_to",kind:i,insertText:"map_to",range:e},{label:"map_from",kind:i,insertText:"map_from",range:e},{label:"returns",kind:i,insertText:"returns",range:e},{label:"pivot",kind:i,insertText:"pivot",range:e,documentation:{value:"The operator transposes several Data Points of the operand Data Set into a single Data Point of the resulting Data Set.  \n\n **Syntax** \n\n    op [ pivot identifier , measure ]   "}},{label:"customPivot",kind:i,insertText:"customPivot",range:e},{label:"unpivot",kind:i,insertText:"unpivot",range:e,documentation:{value:"The unpivot operator transposes a single Data Point of the operand Data Set into several Data Points of the result Data set.  \n\n **Syntax** \n\n    op [ unpivot identifier , measure ]   "}},{label:"sub",kind:i,insertText:"sub",range:e,documentation:{value:"The operator returns a Data Set in a subspace of the one of the input Dataset.  \n\n **Syntax** \n\n    op [ sub identifier = value { , identifier = value }* ]   "}},{label:"apply",kind:i,insertText:"apply",range:e},{label:"conditioned",kind:i,insertText:"conditioned",range:e},{label:"period_indicator",kind:o,insertText:"period_indicator ",range:e,documentation:{value:"period_indicator returns the period indicator of a time_period value. The period indicator is the part of the time_period value which denotes the duration of the time period (e.g. day, week, month \u2026).      \n\n **Syntax** \n\n    period_indicator(op) "}},{label:"single",kind:i,insertText:"single",range:e},{label:"duration",kind:i,insertText:"duration",range:e},{label:"time_agg",kind:o,insertText:"time_agg",range:e,documentation:{value:"The operator converts a time, date or time_period value from a smaller to a larger duration.   \n\n **Syntax** \n\n    time_agg(periodIndTo { ,periodIndFrom } { ,op } { ,first | last }) "}},{label:"unit",kind:i,insertText:"unit",range:e},{label:"value",kind:i,insertText:"value",range:e},{label:"valuedomains",kind:i,insertText:"valuedomains",range:e},{label:"variables",kind:i,insertText:"variables",range:e},{label:"input",kind:i,insertText:"input",range:e},{label:"output",kind:i,insertText:"output",range:e},{label:"cast",kind:o,insertText:"cast",range:e,documentation:{value:"This operator converts the scalar type of op to the scalar type specified by scalarType.  It returns a copy of op converted to the specified scalarType.   \n\n **Syntax** \n\n    cast ( op , scalarType { , mask} ) "}},{label:"rule_priority",kind:i,insertText:"rule_priority",range:e},{label:"dataset_priority",kind:i,insertText:"dataset_priority",range:e},{label:"default",kind:i,insertText:"default",range:e},{label:"check_datapoint",kind:o,insertText:"check_datapoint",range:e,documentation:{value:"\n\n*Syntax*\n\n    check_datapoint( op , dpr { components listComp } { output }) "}},{label:"check_hierarchy ",kind:o,insertText:"check_hierarchy ",range:e,documentation:{value:"The check_hierarchy operator applies the Rules of the Ruleset hr to check the Code Items Relations between the Code Items present in op    \n\n **Syntax** \n\n    check_hierarchy ( op , hr { condition condComp { , condComp }* } { rule ruleComp } { mode } { input } { output } )  "}},{label:"computed",kind:i,insertText:"computed",range:e},{label:"non_null",kind:i,insertText:"non_null",range:e},{label:"non_zero",kind:i,insertText:"non_zero",range:e},{label:"partial_null",kind:i,insertText:"partial_null",range:e},{label:"partial_zero",kind:i,insertText:"partial_zero",range:e},{label:"always_null",kind:i,insertText:"always_null",range:e},{label:"always_zero",kind:i,insertText:"always_zero",range:e},{label:"components",kind:i,insertText:"components",range:e},{label:"all_measures",kind:i,insertText:"all_measures",range:e},{label:"scalar",kind:i,insertText:"scalar",range:e},{label:"component",kind:i,insertText:"component",range:e},{label:"datapoint_on_valuedomains",kind:i,insertText:"datapoint_on_valuedomains",range:e},{label:"datapoint_on_variables",kind:i,insertText:"datapoint_on_variables",range:e},{label:"hierarchical_on_valuedomains",kind:i,insertText:"hierarchical_on_valuedomains",range:e},{label:"hierarchical_on_variables",kind:i,insertText:"hierarchical_on_variables",range:e},{label:"set",kind:i,insertText:"set",range:e},{label:"language",kind:i,insertText:"language",range:e},{label:"defdatapoint",kind:s,insertText:["define datapoint ruleset ${0:name} (${1:signature}) is","\t$3","end datapoint ruleset"].join("\n"),insertTextRules:l,documentation:{value:["\tdefine datapoint ruleset ruleSetName (signature) is\n","\t\trule\n","\tend datapoint ruleset"].join("")}},{label:"defhierarchical",kind:s,insertText:["define hierarchical ruleset ${0:name} (${1:signature}) is","\t$3","end hierarchical ruleset"].join("\n"),insertTextRules:l,documentation:{value:["\tdefine hierarchical ruleset ruleSetName (signature) is\n","\t\t{rule}\n","\tend hierarchical ruleset"].join("")}},{label:"defoperator",kind:s,insertText:["define operator ${0:name} (${1:parameter})","returns ${2:returnType} is","","end operator"].join("\n"),insertTextRules:l,documentation:{value:["\tdefine operator operatorName (parameter)\n","\treturns {returnType} is\n","\t{operatorBody}\n","\tend operator"].join("")}}]},88970:(e,n,t)=>{"use strict";t.d(n,{A:()=>o});var a=t(41306),r=(t(96540),t(74848));const o=({imgSas:e})=>(0,r.jsxs)("div",{className:"container",children:[(0,r.jsxs)("div",{className:"row",children:[(0,r.jsx)("div",{className:"col col--3"}),(0,r.jsxs)("div",{className:"col col--6 centered-content",children:[(0,r.jsx)("h3",{children:"Sas"}),(0,r.jsx)("img",{src:(0,a.Ay)(`/img/sas-vtl/${e}`),alt:"Img Sas"})]})]}),(0,r.jsx)("h3",{className:"centered-content",children:"VTL"})]})},16503:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>a,toc:()=>m});const a=JSON.parse('{"id":"user-guide/vtl/sas-vtl/drop","title":"Drop","description":"","source":"@site/i18n/fr/docusaurus-plugin-content-docs/current/user-guide/vtl/sas-vtl/drop.mdx","sourceDirName":"user-guide/vtl/sas-vtl","slug":"/user-guide/vtl/sas-vtl/drop","permalink":"/Trevas/fr/user-guide/vtl/sas-vtl/drop","draft":false,"unlisted":false,"editUrl":null,"tags":[],"version":"current","lastUpdatedAt":1755197142000,"frontMatter":{"id":"drop","title":"Drop","sidebar_label":"Drop","slug":"/user-guide/vtl/sas-vtl/drop","custom_edit_url":null},"sidebar":"docs","previous":{"title":"Keep","permalink":"/Trevas/fr/user-guide/vtl/sas-vtl/keep"},"next":{"title":"Rename","permalink":"/Trevas/fr/user-guide/vtl/sas-vtl/rename"}}');var r=t(74848),o=t(28453),i=t(88970),s=t(50748);const l={id:"drop",title:"Drop",sidebar_label:"Drop",slug:"/user-guide/vtl/sas-vtl/drop",custom_edit_url:null},d=void 0,c={},m=[];function u(e){return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.A,{imgSas:"drop/sas.png"}),"\n",(0,r.jsx)(s.A,{script:"ds_out := ds_in [drop a, b, c];"})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u()}},5890:(e,n,t)=>{var a={"./simpleWorker":45585,"./simpleWorker.js":45585,"monaco-editor/esm/vs/base/common/worker/simpleWorker":45585,"monaco-editor/esm/vs/base/common/worker/simpleWorker.js":45585};function r(e){return Promise.resolve().then((()=>{if(!t.o(a,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return t(a[e])}))}r.keys=()=>Object.keys(a),r.id=5890,e.exports=r},9204:(e,n,t)=>{var a={"./editorBaseApi":[93059],"./editorBaseApi.js":[93059],"./editorSimpleWorker":[14003],"./editorSimpleWorker.js":[14003],"./editorWorker":[90304],"./editorWorker.js":[90304],"./editorWorkerHost":[96358],"./editorWorkerHost.js":[96358],"./findSectionHeaders":[99307],"./findSectionHeaders.js":[99307],"./getIconClasses":[78148],"./getIconClasses.js":[78148],"./languageFeatureDebounce":[12060],"./languageFeatureDebounce.js":[12060],"./languageFeatures":[52230],"./languageFeatures.js":[52230],"./languageFeaturesService":[16127],"./languageFeaturesService.js":[16127],"./languageService":[83930],"./languageService.js":[83930],"./languagesAssociations":[55996],"./languagesAssociations.js":[55996],"./languagesRegistry":[66995],"./languagesRegistry.js":[66995],"./markerDecorations":[80886],"./markerDecorations.js":[80886],"./markerDecorationsService":[90011],"./markerDecorationsService.js":[90011],"./model":[64830],"./model.js":[64830],"./modelService":[40931],"./modelService.js":[40931],"./resolverService":[37042],"./resolverService.js":[37042],"./semanticTokensDto":[19376],"./semanticTokensDto.js":[19376],"./semanticTokensProviderStyling":[27642],"./semanticTokensProviderStyling.js":[27642],"./semanticTokensStyling":[82891],"./semanticTokensStyling.js":[82891],"./semanticTokensStylingService":[38148],"./semanticTokensStylingService.js":[38148],"./textModelSync/textModelSync.impl":[81171],"./textModelSync/textModelSync.impl.js":[81171],"./textModelSync/textModelSync.protocol":[45628,5628],"./textModelSync/textModelSync.protocol.js":[45628,3247],"./textResourceConfiguration":[41504],"./textResourceConfiguration.js":[41504],"./treeSitterParserService":[35320],"./treeSitterParserService.js":[35320],"./treeViewsDnd":[2603],"./treeViewsDnd.js":[2603],"./treeViewsDndService":[26756],"./treeViewsDndService.js":[26756],"./unicodeTextModelHighlighter":[49887],"./unicodeTextModelHighlighter.js":[49887],"monaco-editor/esm/vs/editor/common/services/editorBaseApi":[93059],"monaco-editor/esm/vs/editor/common/services/editorBaseApi.js":[93059],"monaco-editor/esm/vs/editor/common/services/editorSimpleWorker":[14003],"monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js":[14003],"monaco-editor/esm/vs/editor/common/services/editorWorker":[90304],"monaco-editor/esm/vs/editor/common/services/editorWorker.js":[90304],"monaco-editor/esm/vs/editor/common/services/editorWorkerHost":[96358],"monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js":[96358],"monaco-editor/esm/vs/editor/common/services/findSectionHeaders":[99307],"monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js":[99307],"monaco-editor/esm/vs/editor/common/services/getIconClasses":[78148],"monaco-editor/esm/vs/editor/common/services/getIconClasses.js":[78148],"monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce":[12060],"monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js":[12060],"monaco-editor/esm/vs/editor/common/services/languageFeatures":[52230],"monaco-editor/esm/vs/editor/common/services/languageFeatures.js":[52230],"monaco-editor/esm/vs/editor/common/services/languageFeaturesService":[16127],"monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js":[16127],"monaco-editor/esm/vs/editor/common/services/languageService":[83930],"monaco-editor/esm/vs/editor/common/services/languageService.js":[83930],"monaco-editor/esm/vs/editor/common/services/languagesAssociations":[55996],"monaco-editor/esm/vs/editor/common/services/languagesAssociations.js":[55996],"monaco-editor/esm/vs/editor/common/services/languagesRegistry":[66995],"monaco-editor/esm/vs/editor/common/services/languagesRegistry.js":[66995],"monaco-editor/esm/vs/editor/common/services/markerDecorations":[80886],"monaco-editor/esm/vs/editor/common/services/markerDecorations.js":[80886],"monaco-editor/esm/vs/editor/common/services/markerDecorationsService":[90011],"monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js":[90011],"monaco-editor/esm/vs/editor/common/services/model":[64830],"monaco-editor/esm/vs/editor/common/services/model.js":[64830],"monaco-editor/esm/vs/editor/common/services/modelService":[40931],"monaco-editor/esm/vs/editor/common/services/modelService.js":[40931],"monaco-editor/esm/vs/editor/common/services/resolverService":[37042],"monaco-editor/esm/vs/editor/common/services/resolverService.js":[37042],"monaco-editor/esm/vs/editor/common/services/semanticTokensDto":[19376],"monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js":[19376],"monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling":[27642],"monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js":[27642],"monaco-editor/esm/vs/editor/common/services/semanticTokensStyling":[82891],"monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js":[82891],"monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService":[38148],"monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js":[38148],"monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl":[81171],"monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js":[81171],"monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol":[45628,866],"monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol.js":[45628,8485],"monaco-editor/esm/vs/editor/common/services/textResourceConfiguration":[41504],"monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js":[41504],"monaco-editor/esm/vs/editor/common/services/treeSitterParserService":[35320],"monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js":[35320],"monaco-editor/esm/vs/editor/common/services/treeViewsDnd":[2603],"monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js":[2603],"monaco-editor/esm/vs/editor/common/services/treeViewsDndService":[26756],"monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js":[26756],"monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter":[49887],"monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js":[49887]};function r(e){if(!t.o(a,e))return Promise.resolve().then((()=>{var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}));var n=a[e],r=n[0];return Promise.all(n.slice(1).map(t.e)).then((()=>t(r)))}r.keys=()=>Object.keys(a),r.id=9204,e.exports=r}}]);